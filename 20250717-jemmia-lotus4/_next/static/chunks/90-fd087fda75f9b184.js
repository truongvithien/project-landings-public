"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[90],{3561:(e,n,o)=>{o.d(n,{x9:()=>t});let t={ENABLE_LEVA:!1,ENABLE_CONSOLE_LOGS:!1,ENABLE_DEBUG_UI:!1,ENABLE_DEBUG_INFO:!1}},8090:(e,n,o)=>{o.d(n,{J:()=>x});var t=o(5155),a=o(2115),r=o(1949),i=o(7558),s=o(1401),l=o(8751),c=o(8435),m=o(4688),f=o(9311),u=o(3264),p=o(2072),d=o(3561);let v=(0,s.b)({uTime:0,uResolution:new u.I9Y(512,512),uIorR:2.42,uIorG:2.43,uIorB:2.44,uChromaticAberration:.02,uRefractPower:.3,uFresnelPower:2,uSaturation:1.2,uShininess:150,uDiffuseness:.2,uTransmission:1,uThickness:.5,uEnvMapIntensity:2,envMap:null},"\n    varying vec3 vWorldPosition;\n    varying vec3 vWorldNormal;\n    varying vec3 vEyeVector;\n    varying vec2 vUv;\n    \n    void main() {\n      vUv = uv;\n      \n      // Transform position to world space\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      \n      // Transform normal to world space\n      vWorldNormal = normalize(normalMatrix * normal);\n      \n      // Calculate eye vector (camera to vertex)\n      vEyeVector = normalize(vWorldPosition - cameraPosition);\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ","\n    precision highp float;\n    \n    uniform float uTime;\n    uniform vec2 uResolution;\n    uniform float uIorR;\n    uniform float uIorG; \n    uniform float uIorB;\n    uniform float uChromaticAberration;\n    uniform float uRefractPower;\n    uniform float uFresnelPower;\n    uniform float uSaturation;\n    uniform float uShininess;\n    uniform float uDiffuseness;\n    uniform float uTransmission;\n    uniform float uThickness;\n    uniform float uEnvMapIntensity;\n         uniform sampler2D envMap;\n     \n     varying vec3 vWorldPosition;\n     varying vec3 vWorldNormal;\n     varying vec3 vEyeVector;\n     varying vec2 vUv;\n     \n     // Saturation function\n     vec3 saturation(vec3 rgb, float adjustment) {\n       const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n       vec3 intensity = vec3(dot(rgb, W));\n       return mix(intensity, rgb, adjustment);\n     }\n     \n     // Fresnel effect\n     float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\n       float fresnelFactor = abs(dot(eyeVector, worldNormal));\n       float inversefresnelFactor = 1.0 - fresnelFactor;\n       return pow(inversefresnelFactor, power);\n     }\n     \n     // Specular lighting (Blinn-Phong)\n     float specular(vec3 lightDirection, vec3 eyeVector, vec3 normal, float shininess) {\n       vec3 halfVector = normalize(lightDirection + eyeVector);\n       float NdotH = max(dot(normal, halfVector), 0.0);\n       return pow(NdotH, shininess);\n     }\n     \n     // Convert 3D direction to 2D UV coordinates for environment sampling\n     vec2 directionToUV(vec3 direction) {\n       float u = atan(direction.z, direction.x) / (2.0 * 3.14159265359) + 0.5;\n       float v = asin(direction.y) / 3.14159265359 + 0.5;\n       return vec2(u, v);\n     }\n     \n     // Sample environment map with proper UV mapping\n     vec3 sampleEnvMap(vec3 direction) {\n       vec2 uv = directionToUV(normalize(direction));\n       return texture2D(envMap, uv).rgb;\n     }\n    \n    void main() {\n      vec3 normal = normalize(vWorldNormal);\n      vec3 eyeVector = normalize(vEyeVector);\n      \n      // Calculate refraction for each color channel\n      float iorRatio = 1.0 / uIorG;\n      vec3 refractVector = refract(eyeVector, normal, iorRatio);\n      \n      vec3 finalColor = vec3(0.0);\n      \n      // Chromatic dispersion with multiple samples for smooth effect\n      const int SAMPLES = 7;\n      vec3 colorSum = vec3(0.0);\n      \n      for(int i = 0; i < SAMPLES; i++) {\n        float slide = float(i) / float(SAMPLES) * 0.1;\n        \n        // Calculate individual IOR ratios for RGB\n        float iorRatioR = 1.0 / (uIorR + slide * uChromaticAberration);\n        float iorRatioG = 1.0 / (uIorG + slide * uChromaticAberration * 0.5);\n        float iorRatioB = 1.0 / (uIorB - slide * uChromaticAberration);\n        \n        // Calculate refraction vectors for each channel\n        vec3 refractVecR = refract(eyeVector, normal, iorRatioR);\n        vec3 refractVecG = refract(eyeVector, normal, iorRatioG);\n        vec3 refractVecB = refract(eyeVector, normal, iorRatioB);\n        \n        // Sample environment map for each channel\n        float r = sampleEnvMap(refractVecR).r;\n        float g = sampleEnvMap(refractVecG).g;\n        float b = sampleEnvMap(refractVecB).b;\n        \n        colorSum += vec3(r, g, b);\n      }\n      \n      // Average the samples\n      colorSum /= float(SAMPLES);\n      \n      // Apply saturation\n      colorSum = saturation(colorSum, uSaturation);\n      \n      // Fresnel effect\n      float fresnelEffect = fresnel(eyeVector, normal, uFresnelPower);\n      \n      // Environment reflection\n      vec3 reflectVector = reflect(eyeVector, normal);\n      vec3 envReflection = sampleEnvMap(reflectVector) * uEnvMapIntensity;\n      \n      // Combine refraction and reflection based on fresnel\n      vec3 refractionColor = colorSum * uTransmission;\n      vec3 reflectionColor = envReflection * fresnelEffect;\n      \n      finalColor = mix(refractionColor, reflectionColor, fresnelEffect * 0.3);\n      \n      // Add specular highlights for extra sparkle\n      vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n      float spec = specular(lightDir, eyeVector, normal, uShininess);\n      finalColor += vec3(spec) * 0.3;\n      \n      // Subtle animation for extra sparkle\n      float sparkle = sin(uTime * 10.0 + vWorldPosition.x * 50.0 + vWorldPosition.y * 50.0) * 0.02;\n      finalColor += vec3(sparkle) * fresnelEffect;\n      \n      // Calculate alpha based on transmission and fresnel for realistic transparency\n      float baseAlpha = uTransmission * 0.9; // Base transparency level\n      float fresnelAlpha = fresnelEffect * 0.4; // Fresnel contribution to opacity\n      float alpha = clamp(baseAlpha + fresnelAlpha, 0.1, 1.0); // Ensure some visibility\n      \n      gl_FragColor = vec4(finalColor, alpha);\n    }\n  ");(0,r.e)({DiamondMaterial:v});let h=e=>{let{rotation:n=[0,0,0],scale:o=1,position:i=[0,0,0],materialConfig:s,enableRotation:l=!1,rotationSpeed:c=.005,useCustomEnvironment:m=!0}=e,p=(0,a.useRef)(null),d=(0,a.useRef)(null),h=(0,r.G)(f.B,"/ring.glb"),E=(0,r.G)(u.Tap,"/waterB.png");return(0,r.D)(e=>{p.current&&l&&(p.current.rotation.y+=c),d.current&&(d.current.uTime=e.clock.getElapsedTime(),m&&E?(E.wrapS=u.GJx,E.wrapT=u.ghU,E.mapping=u.wfO,d.current.envMap=E):!m&&e.scene.environment&&(d.current.envMap=e.scene.environment))}),(0,a.useEffect)(()=>{h.scene&&s&&(h.scene.scale.setScalar(o),h.scene.position.set(...i),h.scene.rotation.set(...n),h.scene.traverse(e=>{if(e instanceof u.eaF&&e.material){let n=e.material,o=e.name.toLowerCase().includes("metal")||e.name.toLowerCase().includes("band")||e.name.toLowerCase().includes("ring")||n.name.toLowerCase().includes("metal")||n.name.toLowerCase().includes("gold")||n.name.toLowerCase().includes("silver")||n.name.toLowerCase().includes("platinum"),t=e.name.toLowerCase().includes("diamond")||e.name.toLowerCase().includes("gem")||e.name.toLowerCase().includes("stone")||n.name.toLowerCase().includes("diamond")||n.name.toLowerCase().includes("gem")||n.name.toLowerCase().includes("crystal");if(o)n.color=new u.Q1f(s.metal.color),n.metalness=s.metal.metalness,n.roughness=s.metal.roughness,n.envMapIntensity=s.metal.envMapIntensity,n.needsUpdate=!0;else if(t){let n=new v;n.transparent=!0,n.side=u.$EB,n.alphaTest=0,n.depthWrite=!1,n.blending=u.NTi,n.opacity=s.diamond.opacity,e.renderOrder=1,n.uIorR=s.diamond.iorR||2.42,n.uIorG=s.diamond.iorG||2.43,n.uIorB=s.diamond.iorB||2.44,n.uChromaticAberration=s.diamond.chromaticAberration||.02,n.uSaturation=s.diamond.saturation||1.2,n.uFresnelPower=s.diamond.fresnelPower||2,n.uTransmission=s.diamond.transmission,n.uThickness=s.diamond.thickness,n.uEnvMapIntensity=s.diamond.envMapIntensity,d.current=n,e.material=n}}}))},[h,o,i,n,s]),(0,t.jsx)("group",{ref:p,children:(0,t.jsx)("primitive",{object:h.scene})})},E=()=>(0,t.jsxs)("mesh",{children:[(0,t.jsx)("boxGeometry",{args:[1,1,1]}),(0,t.jsx)("meshStandardMaterial",{color:"#cccccc",wireframe:!0})]}),y={metal:{color:"#FFFFFF",metalness:1,roughness:.1,envMapIntensity:1.5},diamond:{color:"#ffffff",transmission:1,opacity:1,metalness:0,roughness:1,ior:2.4,thickness:.5,envMapIntensity:3,clearcoat:1,clearcoatRoughness:0,iorR:2.42,iorG:2.43,iorB:2.44,chromaticAberration:.5,saturation:3.3,fresnelPower:10}},x=e=>{let{className:n="",width:o="100vw",height:r="100vh",enableControls:s=!0,cameraPosition:f=[0,0,5],cameraFov:u=50,ringRotation:v=[0,0,0],ringScale:x=10,ringPosition:g=[0,0,0],ambientLightIntensity:w=.5,directionalLightIntensity:L=10,directionalLightPosition:S=[20,20,50],enableRotation:b=!1,rotationSpeed:A=.005,materialConfig:C=y,environmentPreset:R="city",enableShadows:V=!0,backgroundColor:j="transparent",useCustomEnvironment:N=!0,enableLeva:B=!1,onValuesChange:I}=e,[M,P]=(0,a.useState)(null),_=d.x9.ENABLE_LEVA?(0,p._5)("Ring Transform",{scale:{value:x,min:1,max:30,step:.5},positionX:{value:g[0],min:-10,max:10,step:.1},positionY:{value:g[1],min:-10,max:10,step:.1},positionZ:{value:g[2],min:-10,max:10,step:.1},rotationX:{value:v[0],min:-Math.PI,max:Math.PI,step:.01},rotationY:{value:v[1],min:-Math.PI,max:Math.PI,step:.01},rotationZ:{value:v[2],min:-Math.PI,max:Math.PI,step:.01},autoRotate:b,rotSpeed:{value:A,min:0,max:.05,step:.001}},{collapsed:!B}):{scale:x,positionX:g[0],positionY:g[1],positionZ:g[2],rotationX:v[0],rotationY:v[1],rotationZ:v[2],autoRotate:b,rotSpeed:A},T=B&&d.x9.ENABLE_LEVA?_:{scale:x,positionX:g[0],positionY:g[1],positionZ:g[2],rotationX:v[0],rotationY:v[1],rotationZ:v[2],autoRotate:b,rotSpeed:A};return a.useEffect(()=>{I&&B&&d.x9.ENABLE_LEVA&&I({timestamp:new Date().toISOString(),ringAttributes:{scale:T.scale,position:{x:T.positionX,y:T.positionY,z:T.positionZ},rotation:{x:T.rotationX,y:T.rotationY,z:T.rotationZ},animation:{autoRotate:T.autoRotate,rotationSpeed:T.rotSpeed}},metadata:{environmentPreset:R,enableShadows:V,useCustomEnvironment:N,cameraPosition:f,cameraFov:u}})},[T.scale,T.positionX,T.positionY,T.positionZ,T.rotationX,T.rotationY,T.rotationZ,T.autoRotate,T.rotSpeed,I,B,R,V,N,f,u]),d.x9.ENABLE_LEVA&&(0,p._5)("Export",{"Export JSON":(0,p.x6)(()=>{let e=new Blob([JSON.stringify({timestamp:new Date().toISOString(),ringAttributes:{scale:T.scale,position:{x:T.positionX,y:T.positionY,z:T.positionZ},rotation:{x:T.rotationX,y:T.rotationY,z:T.rotationZ},animation:{autoRotate:T.autoRotate,rotationSpeed:T.rotSpeed}},metadata:{environmentPreset:R,enableShadows:V,useCustomEnvironment:N,cameraPosition:f,cameraFov:u}},null,2)],{type:"application/json"}),n=URL.createObjectURL(e),o=document.createElement("a");o.href=n,o.download="ring-attributes-".concat(Date.now(),".json"),document.body.appendChild(o),o.click(),document.body.removeChild(o),URL.revokeObjectURL(n)})},{collapsed:!B}),(0,t.jsxs)("div",{className:n,style:{width:o,height:r,position:"absolute",backgroundColor:"transparent"===j?"transparent":j,pointerEvents:"none"},children:[B&&d.x9.ENABLE_LEVA&&(0,t.jsx)(p.XA,{collapsed:!1}),M?(0,t.jsx)("div",{className:"flex items-center justify-center h-full",children:(0,t.jsxs)("div",{className:"text-center",children:[(0,t.jsx)("p",{className:"text-red-500 mb-2",children:"Failed to load 3D model"}),(0,t.jsx)("p",{className:"text-sm text-gray-500",children:M})]})}):(0,t.jsxs)(i.Hl,{camera:{position:f,fov:u},shadows:V,gl:{antialias:!0,alpha:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!1,powerPreference:"high-performance",sortObjects:!0},style:{pointerEvents:s?"auto":"none"},children:[(0,t.jsx)(l.OH,{preset:R}),(0,t.jsx)("ambientLight",{intensity:w}),(0,t.jsx)("directionalLight",{position:S,intensity:L,castShadow:V,"shadow-mapSize-width":2048,"shadow-mapSize-height":2048}),(0,t.jsx)("pointLight",{position:[5,5,5],intensity:8,color:"#ffffff",decay:2}),(0,t.jsx)("pointLight",{position:[-3,4,3],intensity:6,color:"#f8f8ff",decay:2}),(0,t.jsx)("pointLight",{position:[0,6,0],intensity:4,color:"#ffffff",decay:2}),(0,t.jsx)("pointLight",{position:[-5,-2,2],intensity:3,color:"#ffeaa7",decay:2}),(0,t.jsx)("pointLight",{position:[0,0,-8],intensity:2,color:"#e6f3ff",decay:2}),(0,t.jsx)(a.Suspense,{fallback:(0,t.jsx)(E,{}),children:(0,t.jsx)(h,{rotation:B&&d.x9.ENABLE_LEVA?[T.rotationX,T.rotationY,T.rotationZ]:v,scale:B&&d.x9.ENABLE_LEVA?T.scale:x,position:B&&d.x9.ENABLE_LEVA?[T.positionX,T.positionY,T.positionZ]:g,materialConfig:C,enableRotation:B&&d.x9.ENABLE_LEVA?T.autoRotate:b,rotationSpeed:B&&d.x9.ENABLE_LEVA?T.rotSpeed:A,useCustomEnvironment:N})}),V&&(0,t.jsx)(c._,{position:[0,-1,0],opacity:.4,scale:10,blur:1,far:10}),s&&(0,t.jsx)(m.N,{enablePan:!0,enableZoom:!0,enableRotate:!0,minDistance:2,maxDistance:20})]})]})}}}]);